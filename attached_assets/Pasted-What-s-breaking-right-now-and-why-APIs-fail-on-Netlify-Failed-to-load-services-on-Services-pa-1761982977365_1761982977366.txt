What’s breaking right now (and why)

APIs fail on Netlify → “Failed to load services” on Services page

Your /api/services route reads from the database via storage.getAllServices(...) (Drizzle → Postgres) 

routes

, implemented in DatabaseStorage as SQL selects (not REST) 

storage-db

.

The Express app requires a Postgres connection string at start (either DATABASE_URL, or it builds a Supabase pooler URL from SUPABASE_URL + SUPABASE_DB_PASSWORD) 

app

. If those envs aren’t set (or mis-set), the app throws and the Netlify function can’t boot, so every /api/* call 500s — exactly the symptom you’re seeing on the Services page (which calls /api/categories and /api/services) 

Services

.

Also, your Netlify config routes /api/* to the single serverless function “api” (which boots the whole Express app) 

netlify

. If app start fails, all API endpoints fail.

Admin login not opening

Admin login uses sessions backed by Postgres (express-session + connect-pg-simple) and a Neon Pool using the same connection string above 

app

. If the DB connection (or SESSION_SECRET) isn’t available in production, sessions can’t be created and login can’t stick.

Admin endpoints rely on that session (e.g., /api/admin/check returns isAdmin by reading the session) 

routes

.

Missing SESSION_SECRET in production throws an error at boot (this line actively enforces it) 

app

. That alone will stop everything.

Login / Register don’t route to Profile, and Profile isn’t auth-guarded

The current Login/Register pages are stubs and don’t wire to any auth backend; after “success” they route you to /dashboard or elsewhere, not /profile. The Profile page is purely local state with mock data and no auth check (so non-logged-in users aren’t redirected) 

Profile

.

Single-page app deep links

Your Netlify config maps /api/* correctly, but there is no SPA history fallback for client routes (e.g., /services, /profile) — so direct visits may 404 instead of serving index.html. There’s no /* → /index.html rule in netlify.toml right now (we can see only API and webhook redirects) 

netlify

.

Optional but noisy: OpenRouter / Razorpay not configured

The AI concierge endpoint requires OPENROUTER_API_KEY and returns a 500 if it’s missing 

routes

.

Payment endpoints will error if Razorpay keys aren’t set (they’re checked and 500 with a friendly error) 

routes

.

What you asked: “No pooled DB, use API key + URL”

Your codebase currently constructs a Supabase pooler connection for all DB + session IO (Postgres driver via Neon, Drizzle ORM) 

app

. On serverless, that pattern is common, but you asked to avoid pooled DB connections entirely and instead use Supabase URL + API key. That means:

Replace all direct SQL with Supabase REST using @supabase/supabase-js.

Replace Postgres session store (connect-pg-simple) with a stateless, signed cookie (JWT/iron-session/cookie-session) so no DB connection is needed to remember admin auth.

This approach is serverless-native: it eliminates DB sockets and “too many clients” risks and only uses HTTPS to Supabase.

Exact brief for Replit AI (copy-paste)

Goal: Make the app fully serverless-safe on Netlify by removing all DB sockets/pooling. Do not use Supabase/Neon pooler. Use Supabase URL + API keys only (REST) everywhere. Also implement these UX rules:

After login/register → auto-redirect to /profile.

/profile is protected; non-logged-in users should be asked to login/register and redirected.

Ensure every page and admin panel work on Netlify.

1) Replace DB access with Supabase REST (no Postgres clients)

Delete/retire code that builds/uses a Postgres connection string (e.g., the getConnectionString and Neon Pool in server/app.ts) and anything that relies on DATABASE_URL or the pooler string built from SUPABASE_URL + SUPABASE_DB_PASSWORD 

app

.

Remove Drizzle + Neon usage from the request path (e.g., server/storage-db.ts methods like getAllServices, createOrder, etc., which currently use SQL via db) and re-implement them using @supabase/supabase-js with the Supabase REST API. Preserve the return shapes expected by routes like /api/services, /api/categories, /api/orders, etc. (see how routes read from storage) 

storage-db

 

routes

 

routes

.

Server-side, instantiate Supabase with SUPABASE_URL + SUPABASE_SERVICE_ROLE_KEY (needed to bypass RLS for admin/protected actions). On the client, use NEXT_PUBLIC_SUPABASE_URL + NEXT_PUBLIC_SUPABASE_ANON_KEY.

Keep all route URLs exactly the same so the frontend keeps working: /api/services, /api/categories, /api/cart, /api/orders, /api/admin/*, /api/site-content/*, /api/ai/concierge, etc. (See server/routes.ts for the complete list) 

routes

 

routes

 

routes

.

2) Replace session-based admin auth with stateless signed cookies

Remove connect-pg-simple and the Neon Pool used for the session store in server/app.ts 

app

.

Implement admin auth as a stateless signed cookie (JWT/iron-session/cookie-session) using SESSION_SECRET.

/api/admin/login: verify credentials against ADMIN_USERNAME + ADMIN_PASSWORD_HASH (same logic as now), then set a signed cookie; no DB needed (see existing admin verify helper) 

auth

 

auth

.

/api/admin/check: read the cookie to decide isAdmin, mirroring the current semantics (it currently checks req.session?.adminId) 

routes

.

/api/admin/logout: clear the cookie.

Remove any session table requirements.

3) Auth flows for end users + Profile routing/guard

Implement Supabase Auth (email/password) on the client with @supabase/supabase-js.

After successful login or register, navigate to /profile.

Protect /profile: on mount, check the client’s Supabase auth session. If no session, toast “Please login or register first” and redirect to /login. The profile page is currently mock-data only (see local state) — replace with data pulled from Supabase profiles table, keeping existing UI intact 

Profile

.

4) Fix “Failed to load services” on Netlify

After step (1), /api/categories and /api/services should read via Supabase REST (no SQL sockets), so they’ll work in Netlify Functions. The Services page fetches those two endpoints (React Query) — keep the same URLs and signatures so the UI recovers 

Services

.

5) Netlify config — SPA fallback + envs

Add SPA fallback in netlify.toml so client routes load on refresh/deep link. Keep the existing /api/* and /api/payment/webhook redirects untouched 

netlify

.

Add: [[redirects]] from = "/*" to = "/index.html" status = 200

Ensure these envs are set in Netlify UI:

NEXT_PUBLIC_SUPABASE_URL = your URL

NEXT_PUBLIC_SUPABASE_ANON_KEY = your anon key

SUPABASE_SERVICE_ROLE_KEY = service role key (server-only)

SESSION_SECRET = strong random string

Optional: OPENROUTER_API_KEY (AI concierge), RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET (payments)

6) Keep everything else intact

Do not change client routes or visual design.

Preserve all /api/* endpoints and their response shapes so pages like Admin Dashboard, Orders, Tickets, Notifications, Site Content continue to function; only their storage layer changes from SQL to Supabase REST (see routes coverage) 

routes